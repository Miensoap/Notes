
운영체제는 프로그램들에게 자원 할당 (CPU , 입출력장치 등)
**커널(kernel) 영역**

응용 프로그램이 자원에 직접 접근하면 위험
-> 오직 운영체제를 통해서만 접근

**이중 모드** : CPU가 명령어를 실행하는 모드를 구분
- 사용자 모드 : 운영체제의 서비스 X 커널 영역 코드 실행 불가
- 커널 모드 : 운영체제의 서비스 O , 자원 접근 등 모든 명령어 실행 가능
	플래그 레지스터의 '슈퍼바이저 플래그' 로 구분

**시스템 호출** : 커널 모드로 전환 위한 소프트웨어 인터럽트

**운영체제의 핵심 서비스**
- 프로세스 관리 : 실행 중인 프로그램
	- 프로세스 / 스레드 , 프로세스 동기화, 교착상태 해결
- 자원 접근 및 할당 
	1. CPU 스케줄링
	2. 메모리 (페이징 , 스와핑 ... )
	3. 입출력장치 (인터럽트 서비스 루틴)
- 파일 시스템 관리 : 파일 - 폴더(디렉터리 ) 단위로 저장 장치에 보관

---

#### 프로세스
---

foreground / background process
데몬(daemon) , 서비스(service) : 사용자와 상호작용 X 프로세스

**프로세스 제어 블록** (PCB)
프로세스들은 돌아가며 한정된 시간 만큼 CPU 이용
- 타이머 인터럽트
-> 프로세스 관리 위해 사용하는 자료구조 = PCB
	프로세스 생성 시 커널 영역에 생성, 종료시 폐기

	- PID : 특정 프로세스 식별 위해 부여하는 고유한 번호
	- 레지스터 값 : 실행 차례가 돌아오면 이전까지 사용한 레지스터 중간 값들 복원해 재개
			- 프로세스 카운터, 스택 포인터 ... 
	- 프로세스 상태 
	- CPU 스케줄링 정보 
	- 메모리 정보 : 프로세스가 저장된 주소. 페이지 테이블 정보
	- 사용한 파일과 입출력장치 정보

**문맥 교환** (context switch)
- 문맥(context) : 지금까지의 중간 정보. 실행 재개 위해 백업
 기존에 실행되던 프로세스의 중간 정보(문맥)을 백업하고 실행할 프로세스의 문맥 복구

**메모리 영역**
- 코드 영역(= 텍스트 영역)
	- 실행할 수 있는 코드, 기계어로 이루어진 명령어 저장
	- read-only
- 데이터 영역 
	- 프로그램이 실행되는 동안 유지할 데이터 (전역변수)
- 힙 영역 
	- 프로그래머가 할당할 수 있는 저장공간
- 스택 영역
	- 데이터가 일시적 저장 (매개변수, 지역변수)

	힙, 스택 영역의 크기는 가변적 (힙은 낮은주소부터, 스택은 높은주소부터)


**프로세스 상태**
- 생성 상태 : 막 메모리에 적재되어 PCB 할당
- 준비 상태 : 차례를 기다리는 상태 (디스패치 -> 실행)
- 실행 상태 : CPU 할당받아 실행중 (타이머 인터럽트 ->준비 / 입출력 요청-> 대기)
- 대기 상태 : 실행중 입출력장치 사용 (입출력 완료 -> 준비)
- 종료 상태 : PCB , 메모리 영역 정리

**프로세스 계층 구조**
- 부모 프로세스 - 자식 프로세스 : (시스템 호출을 통해) 생성
- 부모- 자식은 별개의 프로세스, 서로 다른 PID
*pstree 명령어

**복제와 옷 갈아입기** : Fork - exec 프로세스 생성 기법
- 부모 프로세스는 fork 시스템 호출을 통해 자신의 복사본을 생성 (자원 상속)
- 자식 프로세스는 exec 시스템 호출을 통해 자신의 메모리 공간을 교체 (덮어쓰기)

---

**스레드** (thread) : 프로세스를 구성하는 실행 흐름의 단위
- 스레드 ID, 레지스터 값(프로그램 카운터 등) , 스택 
- 프로세스 내 자원 공유 -> 실행 위한 최소한의 정보

**멀티 프로세스 vs 멀티 스레드**
- 자원 공유 여부
*IPS (프로세스 간 통신)

---

#### CPU 스케줄링
---

**프로세스 우선순위(priority)**
- 입출력 집중 프로세스 > CPU 집중 프로세스

**스케줄링 큐**
- 준비 큐 
- 대기 큐 : 요구한 장치별로 같은 큐에서 대기

선점형 (preemptive) 스케줄링 : CPU의 자원을 빼앗아 쓸 수 있음 
	-> 문맥교환시 오버헤드 , 골고루 이용
비선점형 스케줄링 

**스케줄링 알고리즘**
1. 선입 선처리 = FCFS(First Come First Served) : 비선점, 호위 효과
2. 최단 작업 우선 = SJF(Shortest Job First) : 비선점
3. 라운드 로빈 = RR(Round Robin) : 선입선처리 + 타임 슬라이스 , 돌아가며 선점형
4. 최소 잔여 시간 우선 = SRT(Shortest Remaining Time) : 최단작업우선+라운드로빈
5. 우선순위 : 우선순위가 같다면 선입선처리, 기아현상(starvation) 문제 -> 에이징(aging)
6. 다단계 큐 = Multilevel queue , 우선순위별로 준비 큐를 여러개 사용
7. **다단계 피드백 큐** : 다단계 큐 + 큐 간의 이동 가능 -> 기아현상 해결

##### 동기화
---


**실행 순서 제어** 
	- reader writer problem

**상호 배제** : 동시에 접근해서는 안 되는 자원에 하나의 프로세스만 접근
	- Bank account problem : '현재 잔액' 공유
	- Producer & Consumer problem : '총합' 변수 =공유 자원
	- 임계 구역 : 동시에 실행하면 문제가 발생하는 자원에 접근하는 코드 영역
	- 레이스 컨디션(Race Condition) : 하나의 자원을 놓고 경쟁하는 상황
	
	1. 상호 배제 (mutual exclusion) 
		한 프로세스가 임계 구역에 진입하면 다른 프로세스는 들어올 수 없다.
	2. 진행 (progress)
		임계 구역에 어떤 프로세스도 진입하지 않닸다면 진입할 수 있다.
	3. 유한 대기 (bounded waiting)
		임계 구역에 들어오기 위해 무한정 대기해서는 안된다.


**뮤텍스 락** (Mutex lock) : 상호 배제를 위한 동기화 도구, 자물쇠 역할
	전역 변수 lock + 임계 구역을 잠그는 acquire 함수+ 해제하는 release 함수
- busy waiting : 반복적으로 lock 확인하며 대기

**세마포** (Semaphore) : 공유 자원이 여러 개인 경우도 적용 가능
	사용 가능한 개수 S +wait함수 + signal 함수 (P/V , down/up)
```
wait (){
	while(S<=0){}
	S--; /* 가능한 자원이 하나 이상이면 하나 줄이고 진입*/
}
```
 Busy waiting 해결 
 -> 사용가능한 자원이 없는 경우 대기 상태 (PCB를 대기 큐에 삽입), 생기면 준비 상태
```
wait(){
	S--;
	if(S<0){
	add this process to Queue;
	sleep();
	}
}

signal(){
	S++
	if(S<=0){
	remove a process p from Queue;
	wakeup(p);
	}
}
```

**모니터** : 개발자가 다루기 편리한 동기화 도구

	상호 배제를 위한 동기화
		- 인터페이스를 위한 큐
		- 공유 자원에 접근하고자 하는 프로세스를 큐에 삽입
		- 큐이 삽입된 순서대로 공유 자원 이용

	실행 순서 제어를 위한 동기화
		- 조건 변수 이용 
		- 조건 충족 x -> wait 조건 충족 -> signal

	모니터 안에는 하나의 프로세스만이 있을 수 있다

**교착 상태(deadlock)**
- **자원 할당 그래프** : 교착 상태 발생 조건 파악

	1. 상호 배제 : 한 프로세스가 사용하는 자원을 다른 프로세스가 사용 불가
	2. 점유와 대기 : 자원을 할당 받은 상태에서 다른 자원을 대기
	3. 비선점 : 어떤 프로세스도 다른 프로세스의 자원을 강제로 빼앗지 못함
	4. 원형 대기 : 원의 형태로 자원 대기

- **교착 상태 예방** -> 발생 조건 중 하나를 없앤다 
	-> 원형 대기 조건 : 자원에 번호를 붙이고 오름차순으로 할당 (일렬 식탁)
	-> 부작용

- **교착 상태 회피** : 무분별한 자원 할당 X , 자원의 양을 고려해 배분
	- 안전 순서열 : 교착 상태 없이 안전하게 할당할 수 있는 순서
	- 안전 상태 : 교착 상태 없이 모든 프로세스가 자원 할당/종료 가능 
	- 불안전 상태 : 교착 상태 발생 가능
	*은행원 알고리즘

- **교착 상태 검출 후 회복**
	- 선점을 통한 회복 : 해결될 때까지 한 프로세스씩 자원을 몰아줌
	- 프로세스 강제 종료를 통한 회복 
		- 해결까지 한 프로세스씩 강제 종료(->오버헤드) , 모두종료(->작업내역위험)

- 교착 상태 무시 : 타조 알고리즘