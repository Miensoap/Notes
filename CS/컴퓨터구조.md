---

---
### 데이터
---

**bit** : 0과 1을 표현하는 가장 작은 정보 단위
	n비트로 2^n가지의 정보 표현 가능
	
	1byte = 8bit
	kB - MB - GB - TB : 1000배씩

**word** : CPU가 한 번에 처리할 수 있는 정보 단위

	half word - full word - double word

**이진법(binary)**
	0과 1로 수를 표현하는 방법 - 0bXX 로 표기
	2의 보수로 음수 표현 : 모든 0과 1을 뒤집고 1을 더한다

	flag : cpu 내부에서 양수 / 음수 표시
	
십육진법 : 0xXX 로 표기, 각 숫자를 2진수 4자리로 바꾸면 이진수

---

**문자 집합** (character set) : 컴퓨터가 이해할 수 있는 문자의 모음

**encoding** : 문자를 0과 1로 이루어진 문자 코드로 변환
	decoding

**아스키 코드** 
- 7비트로 하나의 문자 표현 -> 2^7 = 128개 문자 표현
- 다른 언어 표현 x 

EUC-KR : 완성형 한글 인코딩 , 글자 하나당 2바이트 코드부여

**UTF-8** (Unicode Transformation Format) : 유니코드 인코딩 방법
- 가변 길이 인코딩 : 인코딩 결과가 1~4바이트

---

### 명령어
---

**어셈블리어(assembly language)** : 0과 1로 이루어진 기계어를 번역한 저급 언어

**컴파일(compile)** : 소스코드가 컴파일러에 의해 목적 코드(저급 언어)로 변환

**인터프리트(interpret)** : 인터프리터에 의해 한 줄씩 실행

*godbolt.org

**명령어 = 연산 코드 + 오퍼랜드

**오퍼랜드** : 연산에 사용될 데이터 / 저장된 위치. '주소 필드'
	없는 경우도, 하나 이상일 경우도 있음
	유효 주소 : 사용될 데이터가 저장된 위치

**연산 코드**
 - 데이터 전송 
- 산술/논리 연산
- 제어 흐름 변경
	*CALL / RETURN
- 입출력 제어

**명령어 주소 지정 방식 (addressing modes)** : 유효 주소를 찾는 방법
- 즉시 주소 지정 방식(immediate) : 직접명시. 크기 제한, 빠름
- 직접 주소 지정 방식(direct) : 유효주소 직접명시, 크기제한
- 간접 주소 지정 방식(indirect) : 유효주소의 주소 명시, 느림
- 레지스터 주소 지정 방식(register) : 데이터가 저장된 레지스터 명시
	 메모리보다 레지스터에 접근하는 것이 빠름
- 레지스터 간접 주소 지정 방식 : 데이터를 메모리에 저장-> 레지스터 명시

##### C언어 컴파일 과정

전처리기 - 컴파일러 - 어셈블러 - 링커

---

### CPU 
---

**ALU** : 계산
피연산자 (레지스터) + 제어신호(제어장치) 
-> 결과값(레지스터), 플래그(플래그 레지스터)

**제어장치**
클럭 : 컴퓨터 부품을 움직이는 시간 단위
명령어 (명령어 레지스터) , 플래그
-> 제어 신호 : to 레지스터 / ALU ,  메모리 , 입출력장치
제어 버스

**레지스터** : CPU 내부의 작은 임시저장장치

	1. 프로그램 카운터 : 메모리에서 가져올 명령어의 주소 (1씩증가)
		- 실행흐름 이동 명령어 실행 / 인터럽트 .. 
	2. 명령어 레지스터 : 읽어들인 해석할 명령어
	3. 메모리 주소 레지스터 : 메모리 주소. (주소버스 통해)
	4. 메모리 버퍼 레지스터 : 메모리와 주고받을 값(데이터 /명령어) (데이터버스)
	5. 플래그 레지스터 : 연산 결과 , CPU상태에 대한 부가정보
	6. 범용 레지스터 : 범용
	7. 스택 포인터 : 스택의 꼭대기를 가리킴 (메모리 스택영역)
	8. 베이스 레지스터 : 주소지정 기준 주소
	
	 변위 주소지정방식. 오퍼랜드 값(변위)와 특정 레지스터 값을 더해 유효주소
		 상대 주소 지정 방식 : 오퍼랜드+프로그램카운터
		 베이스 레지스터 주소 지정 방식 : 베이스에서 오퍼랜드만큼 떨어진 주소


**명령어 사이클**
인출 : 명령어를 읽어옴
간접 : 메모리 접근
실행 

**인터럽트** : 동기(예외)/비동기(HW)
	동기 : CPU가 예기치 못한 상황을 접했을 때
	비동기 : 주로 입출력장치에 의해 발생 알림

	1. 입출력장치가 CPU에 인터럽트 요청 신호
	2. CPU는 실행 사이클이 끝나고 인출 전 인터럽트 여부 확인
	3. 인터럽트 플래그를 통해 가능 여부 확인
	4. 가능하다면 지금까지 작업 백업 (메모리 스택)
	5. 인터럽트 벡터를 참조하여 '인터럽트 서비스 루틴' 실행
	6. 끝나면 4에서 백업해둔 작업을 복구해 실행 재개

*interrupt vector table 

- 컴퓨터 부품들은 '클럭 신호'에 맞춰 움직임
- CPU는 '명령어 사이클'이라는 흐름에 맞춰 명령어 실행

**클럭속도**
HZ 단위(초당 클럭 수)
필요 이상으로 높이면 발열

**코어** : 명령어를 실행하는 부품

**스레드** : 실행 흐름의 단위
HW : 하나의 코어가 동시에 처리하는 명령어 단위. '논리 프로세서'
SW : 하나의 프로그램에서 독립적으로 실행되는 단위

레지스터 세트

**명령어 파이프라인**
1. 명령어 인출(Instruction Fetch)
2. 명령어 해석(Instruction Decode)
3. 명령어 실행(Execute Instruction)
4. 결과 저장(Write Back)

- 같은 단계가 겹치지 않으면 CPU는 각 단계를 동시에 실행 가능

- 파이프라인 위험 : 성능 향상 실패
	- 데이터 위험 : 명령어간의 의존성
	- 제어 위험 : 프로그램 카운터의 변화 -> 분기예측(branch prediction)
	- 구조적 위험 : 서로 다른 명령어가 같은 부품을 쓰려고 할 때
- 슈퍼스칼라 : 여러개의 명령어 파이프라인을 포함한 구조
-> 파이프라인 위험도의 증가로 개수 비례 성능 증가 X

**비순차적 명령어 처리**
의존성 없는 명령어의 순서를 바꿔 처리 -> 결과에 영향 X

**명령어 집합(구조)** : CPU가 이해할 수 있는 명령어들의 모음
CPU 종류에 따라 컴파일된 기계어도 다름

**CISC** (Complex Instructiuon Set Computer)
x86, x86-64
복잡, 가변 길이 명령어 활용
상대적으로 적은 수의 명령어로 프로그램 실행 가능 -> 메모리 절약
명령어 파이프라이닝이 불리

**RISC** (Reduced Instruction Set Computer)
명령어 짧고 규격화. 종류 적음
-> 파이프라이닝 유리
메모리 접근 최소화(load, store), 레지스터 활용 다

---

### 메모리
---

**RAM**
휘발성 저장장치
크면 많은 프로그램을 동시에 실행하는 데 유리

**DRAM (Dynamic RAM)**
저장된 데이터가 동적으로 사라지는 RAM
-> 주기적 재활성화
소비전력 낮고 저렴 집적도 높음 ->대용량 유리
-> 주기억장치 사용

**SRAM (Static RAM)**
빠름. 전력 가격높고 집적도 낮아 -> 대용량 불리
-> 캐시 메모리에 사용

**SDRAM (Synchronous DRAM)**
클럭 신호와 동기화된 DRAM

**DDR SDRAM (Double Data Rate SDRAM)**
대역폭을 넓혀 속도 빠름
	DDR4 SDRAM : 가장대중적

**주소 공간**

물리 주소 : 메모리 입장. HW상 주소
논리 주소 : 프로그램 입장. 프로그램 각각에게 부여된 0부터 시작하는 주소

MMU(메모리 관리 장치) 에 의해 변환
- 논리 주소(거리) 와 베이스 레지스터(프로그램의 첫 물리 주소) 값을 더하여 변환

**한계 레지스터**
- 논리 주소의 최대 크기 저장
- 프로그램의 영역 침범 막음 -> 메모리 보호

**memory hierarchy (메모리 계층 구조)**
	레지스터 - 메모리 - 보조기억장치
	순으로 속도 / 용량 / 가격


**캐시 메모리**
CPU(레지스터)와 메모리 사이 위치
SRAM 기반 저장장치
L1 - L2 - L3 캐시 - 메모리

-> CPU가 자주 사용할 법한 내용을 예측하여 저장  (캐시 히트/미스 - 적중률)

**참조 지역성의 원리**
	1. CPU는 최근 접근했던 메모리 공간에 다시 접근하려는 경향이 있다.
	2. CPU는 접근한 메모리 공간 근처를 접근하려는 경향이 있다.

---

### 보조 기억장치
---

**하드 디스크** 
자기적인 방식으로 저장
	스핀들 + 플래터 + 디스크암(헤드)
트랙 / 섹터 단위 저장 (하나이상의 섹터를 묶어 블록)
실린더 : 여러 겹의 플래터에서 같은 트랙이 위치한 곳. 연속된 정보 기록

탐색 시간(헤드) / 회전 지연 / 전송 시간

**플래시 메모리**
전기적으로 데이터를 읽고 쓰는 반도체 기반 저장 장치
	NAND 플래시 메모리
셀(cell) : 데이터 저장 가장 작은 단위, 1bit = SLC , MLC TLC QLC

페이지의 상태
- Free 상태 : 어떠한 데이터도 X
- Vaild 상태 : 이미 유효한 데이터 저장
- Invaild 상태 : 유효하지 않은 데이터 저장

**가비지 컬렉션**
유효한 페이지들만 새 블록으로 복사->기존 블록 삭제

**RAID** (Redundant Array of Independent Disks)
- 여러 물리적 보조기억장치를 하나의 논리적 장치처럼 사용

- RAID 0 : 단순히 번갈아가며 저장 (stripe) , 입출력 속도 향상, 정보 안전 X
- RAID 1 : mirroring. 복사본. 쓰기속도 느림, 용량 한정
- RAID 4 : 오류 검출 / 복구 위한 정보 저장 = 패리티 비트. 
	단점 : 패리티디스크의 병목
 - RAID 5 : 패리티 정보를 분산 저장
 - RAID 6 : 두 종류의 패리티, 5보다 안전, 쓰기 느림

---

### 입출력 장치
---

종류가 다양하고 전송률이 낮다.
**-> 장치 컨트롤러** 를 통해 컴퓨터와 연결 (HW)
- CPU와 입출력장치 간의 통신 중개
- 오류 검출
- 데이터 버퍼링 : '버퍼' 라는임시 저장공간에 데이터를 저장해 전송률 차이 완화
데이터/ 상태 / 제어 레지스터

**장치 드라이버** (SW)

**프로그램 입출력**
	CPU가 장치 컨트롤러의 레지스터 값을 읽고 씀
	
	1. CPU는 하드 디스크 컨트롤러의 제어 레지스터에 쓰기 명령 내보내기
	2. 컨트롤러는 상태 확인 후 상태 레지스터에 '준비 완료' 표시
	3. CPU는 상태 레지스터를 주기적 확인, 메모리의 정보를 데이터 레지스터에 쓰기 (반복)

	메모리 맵 입출력 : 입출력장치에 접근하기 위한 주소 공간을 메모리처럼 간주
		-> 메모리 접근 명령어 == 입출력장치 접근 명령어
	 고립형 입출력 : 메모리 / 입출력장치 주소공간 분리
		-> 메모리 주소 공간 축소 x,  전용 명령어 사용

**인터럽트 기반 입출력**
	장치 컨트롤러에 의해 하드웨어 인터럽트 발생

	동시다발적 -> 플래그 레지스터의 인터럽트 비트 비활성화로 처리
	NMI (Non - Maskable Interrupt) : 별도의 핀
	PIC(Programmable Interrupt Controller) : 여러 장치 컨트롤러에 연결, 우선순위 판단

**DMA (Direct Memory Access) 입출력**
	CPU를 거치지 않고 입출력장치가 메모리에 직접 접근

	1. CPU가 DMA 컨트롤러에 입출력 작업 명령
	2. DMA 컨트롤러가 CPU 대신 장치 컨트롤러와 상호작용, 필요하면 메모리 접근해 수행
	3. 끝나면 인터럽트를 통해 CPU에게 알림

	시스템 버스는 CPU , DMA가 동시 이용 불가. 
	*Cycle stealing
	
**입출력 버스**
시스템 버스의 불필요한 이용 빈도 낮춤
슬롯 -> 입출력버스 -> 시스템버스