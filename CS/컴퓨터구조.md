---

---
### 데이터
---

**bit** : 0과 1을 표현하는 가장 작은 정보 단위
	n비트로 2^n가지의 정보 표현 가능
	
	1byte = 8bit
	kB - MB - GB - TB : 1000배씩

**word** : CPU가 한 번에 처리할 수 있는 정보 단위

	half word - full word - double word

**이진법(binary)**
	0과 1로 수를 표현하는 방법 - 0bXX 로 표기
	2의 보수로 음수 표현 : 모든 0과 1을 뒤집고 1을 더한다

	flag : cpu 내부에서 양수 / 음수 표시
	
십육진법 : 0xXX 로 표기, 각 숫자를 2진수 4자리로 바꾸면 이진수

---

**문자 집합** (character set) : 컴퓨터가 이해할 수 있는 문자의 모음

**encoding** : 문자를 0과 1로 이루어진 문자 코드로 변환
	decoding

**아스키 코드** 
- 7비트로 하나의 문자 표현 -> 2^7 = 128개 문자 표현
- 다른 언어 표현 x 

EUC-KR : 완성형 한글 인코딩 , 글자 하나당 2바이트 코드부여

**UTF-8** (Unicode Transformation Format) : 유니코드 인코딩 방법
- 가변 길이 인코딩 : 인코딩 결과가 1~4바이트

---

### 명령어
---

**어셈블리어(assembly language)** : 0과 1로 이루어진 기계어를 번역한 저급 언어

**컴파일(compile)** : 소스코드가 컴파일러에 의해 목적 코드(저급 언어)로 변환

**인터프리트(interpret)** : 인터프리터에 의해 한 줄씩 실행

*godbolt.org

**명령어 = 연산 코드 + 오퍼랜드

**오퍼랜드** : 연산에 사용될 데이터 / 저장된 위치. '주소 필드'
	없는 경우도, 하나 이상일 경우도 있음
	유효 주소 : 사용될 데이터가 저장된 위치

**연산 코드**
 - 데이터 전송 
- 산술/논리 연산
- 제어 흐름 변경
	*CALL / RETURN
- 입출력 제어

**명령어 주소 지정 방식 (addressing modes)** : 유효 주소를 찾는 방법
- 즉시 주소 지정 방식(immediate) : 직접명시. 크기 제한, 빠름
- 직접 주소 지정 방식(direct) : 유효주소 직접명시, 크기제한
- 간접 주소 지정 방식(indirect) : 유효주소의 주소 명시, 느림
- 레지스터 주소 지정 방식(register) : 데이터가 저장된 레지스터 명시
	 메모리보다 레지스터에 접근하는 것이 빠름
- 레지스터 간접 주소 지정 방식 : 데이터를 메모리에 저장-> 레지스터 명시

##### C언어 컴파일 과정

전처리기 - 컴파일러 - 어셈블러 - 링커

---

### CPU 
---

**ALU** : 계산
피연산자 (레지스터) + 제어신호(제어장치) 
-> 결과값(레지스터), 플래그(플래그 레지스터)

**제어장치**
클럭 : 컴퓨터 부품을 움직이는 시간 단위
명령어 (명령어 레지스터) , 플래그
-> 제어 신호 : to 레지스터 / ALU ,  메모리 , 입출력장치
제어 버스

**레지스터** : CPU 내부의 작은 임시저장장치

	1. 프로그램 카운터 : 메모리에서 가져올 명령어의 주소 (1씩증가)
		- 실행흐름 이동 명령어 실행 / 인터럽트 .. 
	2. 명령어 레지스터 : 읽어들인 해석할 명령어
	3. 메모리 주소 레지스터 : 메모리 주소. (주소버스 통해)
	4. 메모리 버퍼 레지스터 : 메모리와 주고받을 값(데이터 /명령어) (데이터버스)
	5. 플래그 레지스터 : 연산 결과 , CPU상태에 대한 부가정보
	6. 범용 레지스터 : 범용
	7. 스택 포인터 : 스택의 꼭대기를 가리킴 (메모리 스택영역)
	8. 베이스 레지스터 : 주소지정 기준 주소
	
	 변위 주소지정방식. 오퍼랜드 값(변위)와 특정 레지스터 값을 더해 유효주소
		 상대 주소 지정 방식 : 오퍼랜드+프로그램카운터
		 베이스 레지스터 주소 지정 방식 : 베이스에서 오퍼랜드만큼 떨어진 주소


**명령어 사이클**
인출 : 명령어를 읽어옴
간접 : 메모리 접근
실행 

인터럽트 : 동기(예외)/비동기(HW)
	동기 : CPU가 예기치 못한 상황을 접했을 때
	비동기 : 주로 입출력장치에 의해 발생 알림

	1. 입출력장치가 CPU에 인터럽트 요청 신호
	2. CPU는 실행 사이클이 끝나고 인출 전 인터럽트 여부 확인
	3. 인터럽트 플래그를 통해 가능 여부 확인
	4. 가능하다면 지금까지 작업 백업 (메모리 스택)
	5. 인터럽트 벡터를 참조하여 인터럽트 서비스 루틴 실행
	6. 끝나면 4에서 백업해둔 작업을 복구해 실행 재개

*interrupt vector table 

- 컴퓨터 부품들은 '클럭 신호'에 맞춰 움직임
- CPU는 '명령어 사이클'이라는 흐름에 맞춰 명령어 실행

**클럭속도**
HZ 단위(초당 클럭 수)
필요 이상으로 높이면 발열

**코어** : 명령어를 실행하는 부품

**스레드** : 실행 흐름의 단위
HW : 하나의 코어가 동시에 처리하는 명령어 단위. '논리 프로세서'
SW : 하나의 프로그램에서 독립적으로 실행되는 단위

레지스터 세트

**명령어 파이프라인**
1. 명령어 인출(Instruction Fetch)
2. 명령어 해석(Instruction Decode)
3. 명령어 실행(Execute Instruction)
4. 결과 저장(Write Back)

- 같은 단계가 겹치지 않으면 CPU는 각 단계를 동시에 실행 가능

- 파이프라인 위험 : 성능 향상 실패
	- 데이터 위험 : 명령어간의 의존성
	- 제어 위험 : 프로그램 카운터의 변화 -> 분기예측(branch prediction)
	- 구조적 위험 : 서로 다른 명령어가 같은 부품을 쓰려고 할 때
- 슈퍼스칼라 : 여러개의 명령어 파이프라인을 포함한 구조
-> 파이프라인 위험도의 증가로 개수 비례 성능 증가 X

**비순차적 명령어 처리**
의존성 없는 명령어의 순서를 바꿔 처리 -> 결과에 영향 X

**명령어 집합** : CPU가 이해할 수 있는 명령어들의 모음